myfiles = dir(rawdatapath, full.names=TRUE, pattern = '*IR.csv')
#		gapecombo=dir(path=rawdatapath, full.names = TRUE, pattern=paste0(i,"_GAPE.csv"))
if(length(myfiles)==0){
next # if there are no data files found, skip to next serial number
}
# pull HR data and put in Heart
for (i in 1:length(myfiles)){
if(exists('temp')) {rm(temp)} # clear old version of temp
hdr  = scan(myfiles[i], nlines = 1, what = character(),sep = ',', quiet = TRUE)
# Use the try() function to handle cases where the input file
# might be empty
try(temp <- read.table(myfiles[i],skip = 1, header = FALSE,
sep = ',', na.strings=c("","NA")), silent=TRUE)
if (!exists('temp')){
next  # If the data frame temp wasn't created, skip the rest
# of this iteration of the loop
}
colnames(temp) = hdr
temp$DateTime = as.POSIXct(temp$DateTime, tz = 'UTC')
# The original data files only had a timestamp every 240 rows
# at the start and end of a 240-sample period. It might be useful
# to fill in the intervening time values
# To preserve this information in csv files, you need to have
# set R's options to show 3 digits on time values:
# options(digits.secs = 3)
################################################################
# Get all rows that have a non-NA timestamp value in them
goodvals = which(!is.na(temp$DateTime))
# Get the subset where the last digit of the row number is a 1
# rather than a 0, since these are the rows at the start of
# each 240-sample chunk (row 1, row 241, row 481 etc.)
startRows = goodvals[which((goodvals %% 10)== 1)]
# Go through the 240 values and add an incrementing milliseconds
# value onto the timestamp.
# Add 0.125 seconds to each reading (8Hz sample rate). Very last reading
# is the last millisecond in 30 seconds. (29.875seconds).
for (k in 1:length(startRows)){
nextStart = startRows[k]
# Generate a set of 240 timestamps incrementing by 0.125sec
tvals = seq(temp$DateTime[nextStart], by = 0.125, length.out = 240)
temp$DateTime[nextStart : (nextStart+240-1)] = tvals
}
if (i == 1) {
Heart = temp
} else if (i > 1){
Heart = rbind(Heart,temp)
}
}
if (loops == 1){
combineddat = Heart
loops = loops + 1
} else if (loops > 1) {
combineddat = rbind(combineddat,Heart)
}
} #end of serial number looping
if (exists('combineddat')){
if (nrow(combineddat) > 0){
Heart = combineddat # copy back over to this data frame for further use
# Make sure the values are all in chronological order, in case
# some raw files were imported out of order when an oyster switched
# serial numbers
Heart = Heart[order(Heart$DateTime),]
# Figure out if there's a time of death associated with this oyster code. Get all of
# the rows that match this oyster code and pull the contents of the timeofdeath column
deathrows = metafile[which(substr(metafile$Code,7,10) == substr(oy,7,10)),'timeofdeath']
# Check to see if any of the values in deathrows is not an NA
if (length(which(!is.na(deathrows))) > 0) {
# If we found a non-NA value in deathrows, grab it and store it in timeofdeath
timeofdeath = deathrows[which(!is.na(deathrows))]
# If there was a time of death listed, truncate the data set there
Heart = Heart[which(Heart$DateTime <= timeofdeath),]
} else {
# There were no non-NA values in deathrows, so set timeofdeath to NA
timeofdeath = NA
}
write.csv(Heart, paste0(comboheartpath, oy, "_comboheart.csv"),
row.names = FALSE)
}
}
} # end of oystercode for loop
close(pb)
# Go through the results lists and visually inspect timepoints where the
# heart rate was flagged as questionable. This may be a one-time thing. Run the
# code in this chunk to open the BPM data and extract the data for your
# desired sensor channel ('mysensor'). Then run the code in the next chunk
# to do the manual inspection. You may save your progress at the end of the
# next chunk (manually) so that it will be available here the next time you
# reopen the data file.
mysensor = 'IR'
oy = 'W.E.3.1010'
# Open up the concatenated heart data for this oyster
Heart = read.csv(paste0(comboheartpath,oy,'_comboheart.csv'))
Heart$DateTime = as.POSIXct(Heart$DateTime, tz = 'UTC')
# Open up the output file from the heart rate auto-processing routine
if (length(dir(path = heartoutputpath,
pattern = paste0(oy,'[[:alnum:][:punct:]]*QA.csv'))) == 1){
# If the QA'd version exists already, load that up
Heartbpm = read.csv(paste0(heartoutputpath, oy,'_bpm_QA.csv'))
} else {
# Reopen the original filtered results file, which hasn't had QA started yet
Heartbpm = read.csv(paste0(heartoutputpath,oy,'_bpm.csv'))
}
# Convert DateTime to POSIX
Heartbpm$DateTime = as.POSIXct(Heartbpm$DateTime, tz = 'UTC')
# The heart beat estimates and quality flags are stored in Heartbpm
# Define a BPM quality threshold. The BPM estimates from the various methods should
# be less than this value, meaning they are in close agreement.
BPMqualityThreshold = 4
# Figure out rows where there's disagreement among the 3 methods and also values haven't
# previously been QA'd. If the row already has been QA'd, this will ignore that row.
# This will pull out any row where the disagreement
# between 2 of the methods is greater than the BPMqualityThreshold
# and the sensor hasn't been QA'd. This will catch rows with
# weak signals though, which may be too many.
checkTheseRows = which( (Heartbpm$BPMagreeQuality.fft.forecast > BPMqualityThreshold |
Heartbpm$BPMagreeQuality.prac.forecast > BPMqualityThreshold |
Heartbpm$BPMagreeQuality.prac.fft > BPMqualityThreshold ) &
Heartbpm$QA == 'FALSE')
# This version requires the WeakSignalFlag field to be OK instead
# of FAIL. Useful in cases where large numbers (thousands) of
# rows would be caught here, but most of them have such a weak signal
# that they're not even worth looking at.
#checkTheseRows = which( (sensor$BPMagreeQuality.fft.forecast > BPMqualityThreshold |
#				sensor$BPMagreeQuality.prac.forecast > BPMqualityThreshold |
#				sensor$BPMagreeQuality.prac.fft > BPMqualityThreshold ) &
#			sensor$QA == 'FALSE' &
#			  sensor$WeakSignalFlag == 'OK')
# Also get the rows with NAs
NArows = which(is.na(Heartbpm$BPMfft) & is.na(Heartbpm$BPMforecast))
# Combine the two sets of bad row indices
badRows = c(checkTheseRows,NArows)
counter = 1 # Start at the first entry in checkTheseRows
if (exists('ManualStart')){
# This won't run automatically, but you can use it to find a starting point in the middle
# of the dataset to start at, if you don't want to start at the first entry
myTime = as.POSIXct('2022-08-22 10:52:30', tz = 'etc/GMT+8')
counter = which.min(abs(myTime - Heartbpm$DateTime[checkTheseRows]))
}
# A function to convert raw heartbeat timeseries into estimates of heart rate
# (beats per minute). This function uses the filtfilt routine from the signal
# library and a butterworth filter. If you specify a particular frequency
# for the lowband (and optionally highband), it will effectively filter
# at half that frequency. For example, if you specify a lowband value of
# 1/10 (0.1 = 10 Hz), you get a lowpass filter that cuts off signals above around 5Hz.
# If you specify 1/20 (0.05 = 5Hz), the lowpass filter filters anything above
# about 2.5Hz.
#' @param x A data frame with columns DateTime and IR for sensor data
#' @param t1 The starting index of data to be subset from x
#' @param sensor Column name in x declaring the sensor that you want to process
#' @param chunklength Number of samples to process, default = 240 is 30 seconds at 8Hz for BivalveBit loggers
#' @param lowband Frequency for the lower frequency of the bandpass filter, consider values from 1/20 to 1/300
#' @param highband Frequency for the upper frequency of the bandpass filter, consider values from 1/2 to 1/20. Set to NULL to
#' implement a lowpass filter only
#' @param amplitudeThreshold Minimum peak to peak amplitude of the *filtered* heart signal
#' @param maxBPM Maximum beats per minute estimate, higher values will be flagged in the output
#' @param Fs Sampling interval in seconds (default 0.125 = 8Hz for BivalveBit loggers)
#' @param BPMqualityThreshold A numeric value indicating how close two heart rate estimates must be to be considered in agreement
#' @param plot Logical value to show a plot or not. Default is FALSE.
#' @param myYlims Set of fixed y-axis limits for plots
#'
#'
#' @return A list containing 3 estimates of the beats per minute, along with
#' values indicating how close the 3 estimates agree and whether the signal may
#' be questionable.
getBPM = function(x,t1 = 1, sensor = 'IR',chunklength=240,
lowband = 1/100,
highband = 1/15,
amplitudeThreshold = 60,
maxBPM = 80,
Fs = 0.125,
BPMqualityThreshold = 4,
plot = FALSE,
myYlims = NULL)
{
temp = x[t1:(t1+chunklength-1),]  #Grab the chunk of data
#
# Grab a chunk of data that's twice as long as we need
#	temp = x[t1:(t1+(chunklength*2)),]
# Calculate time difference between each sample (milliseconds), should be 100
#	diffs = diff(temp$startMillis)
# Identify any gaps in the data where the interval was greater than the sampling interval in milliseconds
#	missedReads = which(diffs > (1000 * Fs))
# Check if there are any sampling gaps (missedReads)
#	if (length(missedReads) > 0){
#		# Add on the final row as well
#		missedReads = c(missedReads, (nrow(temp)+1) )
#		# Calculate gap length between any missed reads (and the final read)
#		testgaps = diff(missedReads)
#		if (missedReads[1] > chunklength){
#			# In this case, just grab the first 300 readings
#			temp = temp[1:chunklength,]
#		} else if (length(which(testgaps>=chunklength)) > 0){
#			# check if any of the testgaps values are >=300 (chunklength)
#			# Get the index in temp that is at the start of the long run
#			tempindx = missedReads[which(testgaps >= chunklength)]+1
#			# If a gap is > 300, grab the sample in that gap
#			temp = temp[tempindx:(tempindx+chunklength-1),]
#		} else if (length( which(testgaps>=chunklength) ) == 0) {
#			# In this case there may be multiple gaps in the time chunk,
#			# so that there are no good contiguous chunks of 300 readings
#			# Return a data frame with NAs
#			temp[,sensor] = NA
#
##			tempindx = missedReads[length(missedReads)]+1
##			temp = temp[tempindx:(tempindx+chunklength-1),]
#			# It's also possible to end up here if you grabbed a chunk that
#			# ran off the end of the 600 samples and returned some NAs. That
#			# will be handled below
#
#		}
#	} else if (length(missedReads) == 0) {
#		# Subset down to exactly the chunk length (10Hz sample * 30 secs = 300 samples)
#		temp = temp[1:chunklength,]
#	}
# Add milliseconds onto the timestamps
temp$DateTimeMS = temp$DateTime
diffs = diff(temp$startMillis) / 1000
temp$DateTimeMS[2:nrow(temp)] = temp$DateTimeMS[1] + cumsum(diffs)
# Test if there are any NAs in the heart rate values, if there are not
# then proceed with the filtering and heart rate determination
if ( length( which( is.na(temp[,sensor]) ) ) == 0){
# Detrend the heartrate readings
detrendedIR = pracma::detrend(temp[,sensor])
# Next look at the detrended values and look for spurious low values
# For instance, a good heart signal might oscillate between -200 & +300
# in the detrended data, and a spurious value might suddenly drop to
# -6000.
# Calculate the standard deviation of the data set, and then find values
# that are more than 3 SD away from the mean (which should be ~zero in the
# detrended data)
#		spuriousVals = which(abs(detrendedIR) > (3*sd(detrendedIR)) )
#		if ( length(spuriousVals) > 0) {
#			# Convert to NAs
#			temp[spuriousVals,sensor] = NA
#
#			for (i in 1:length(spuriousVals)){
#				indx = spuriousVals[i]  # Get the row index for this spurious value
#				if (indx == 1) {
#					# If the first value is spurious, replace it with a copy
#					# of the next value
#					temp[indx,sensor] = temp[indx+1,sensor]
#				} else {
#				# Replace the spurious value with the average of the values immediately
#				# before and after the spurious value
##				temp[indx,sensor] = mean(c(temp[indx-1,sensor],temp[indx+1,sensor]))
#				temp[indx,sensor] = mean(temp[(indx-2):(indx+2),sensor], na.rm=TRUE)
#				}
#			}
#		}
#		rm(spuriousVals)
# With the spurious values replaced by interpolated values, re-run the
# detrending routine
#		detrendedIR = pracma::detrend(temp[,sensor])
} else {
# If there were NAs, just define detrendedIR as NA so that later
# operations skip over this chunk of data
detrendedIR = NA
}
if (length(which(is.na(detrendedIR))) == 0) {
# Define a butterworth filter
# Consider using the bandpass filter rather than just a lowpass filter
# because of the tendency for the IR heartrate signal to drift up and
# down in relation to ambient light, which tends to induce low-frequency
# shifts that then fool the spectral analysis routines when trying to
# identify the dominant frequency
if (!is.null(highband)) {
bf = signal::butter(3,W = c(lowband, highband), type = 'pass')	# bandpass filter
} else if (is.null(highband)){
bf = butter(3,W = lowband, type = 'low')  #  lowpass filter
}
# Apply the filter to the detrended data chunk
y = filtfilt(bf, x = detrendedIR)
# Calculate the spectrum of the filtered data
myfft2 = spectrum(y, plot = FALSE)
# Take the peak frequency from the spectrum, divide by sampling
# rate to convert to cycles per second
mypeakfreq = myfft2$freq[which.max(myfft2$spec)] / Fs
# Multiply by 60 seconds to get cycles (beats) per minute
BPMfft = 60 * mypeakfreq
# Calculate amplitude of filtered signal to denote weak or noisy signals
amp = range(y)[2] - range(y)[1]
# Use function from package 'forecast', returns peak period (not freq)
forecastPeriod = forecast::findfrequency(y)
forecastFreq = 1/forecastPeriod # convert period to frequency
BPMforecast = forecastFreq * 60 * (1/Fs) # convert frequency to beats per
# minute, based on the fact that the sampling period is Fs, and there are
# 60 seconds in a minute
# Set a flag for cases where the forecast:findfrequency estimate is
# extremely large, which happens when it can't find a clear heart signal
BPMforecastflag = ifelse(BPMforecast > maxBPM, 'FAIL','OK')
# Set a flag for cases where the detrended/filtered signal has a very
# small amplitude, signaling that there may be no good heartbeat signal
WeakSignalFlag = ifelse(amp < amplitudeThreshold, 'FAIL','OK')
# Use pracma package to find peaks. Note that at slower heart rates
# this function tends to find the sub-peaks (akin to a P or T peak in a
# human ECG trace) rather than just the main peaks (R peaks on a human).
# This happens based on what the bandpass filter lets through.
pracPeaks = pracma::findpeaks(x = y, nups = 5, minpeakdistance = 10)
BPMprac = nrow(pracPeaks)*2
# Calculate the difference between the estimated heart rates from the
# spectrum fft routine and the forecast::findfrequency routine. A
# small value indicates good agreement
BPMagreeQuality.fft.forecast = ceiling(abs(BPMfft - BPMforecast))
# Calculate difference between the forecast and pracma estimates
BPMagreeQuality.prac.forecast = ceiling(abs(BPMprac - BPMforecast))
# Calculate difference between fft and pracma estimates
BPMagreeQuality.prac.fft = ceiling(abs(BPMprac - BPMfft))
if (plot){
## Plot the raw detrended signal
if (!is.null(myYlims)){
# Use the specified y limits
plot(temp$DateTimeMS, detrendedIR, type = 'l',
main = '', xlab = 'Seconds', ylab = '',
las = 1, ylim = myYlims)
} else if (is.null(myYlims)) {
# No y limits specified, use plot defaults
plot(temp$DateTimeMS, detrendedIR, type = 'l',
main = '', xlab = 'Seconds', ylab = '',
las = 1)
}
points(temp$DateTimeMS, detrendedIR, col = 1, pch = 20, cex = 1)
if (amp > amplitudeThreshold){
lines(temp$DateTimeMS, y, col = 3, lwd = 2) # add the filtered signal as a green line
} else if (amp <= amplitudeThreshold) {
lines(temp$DateTimeMS, y, col = 2, lwd = 2) # add the filtered signal as a red line
warning('Weak signal')
}
points(temp$DateTimeMS[pracPeaks[,2]], y = pracPeaks[,1], col = 4, pch = 19)
mtext(side = 2, text = 'Detrended IR signal', line = 2.5, cex = 1)
mtext(side = 1, line = 3, text = paste(sensor, strftime(temp$DateTimePST[1])), cex = 0.8, adj = 1)
mtext(side = 3, line = 3, text = paste0('pracma bpm: ', BPMprac))
mtext(side = 3, line = 2, text = paste0('fft bpm: ', BPMfft))
mtext(side = 3, line = 1, text = paste0('forecast filtered bpm: ', round(BPMforecast,1)))
if (!is.null(highband)){
mtext(side = 3, line = 0.01,
text = paste0('Bandpass - Lower pass: ', round(lowband,digits =3), ', upper pass: ', round(highband,digits = 3)),
cex = 0.8)
} else if (is.null(highband)) {
mtext(side = 3, line = 0.01,
text = paste0('Lowpass - Lower limit: ', round(lowband,digits =3)),cex = 0.8)
}
}
resultsList = list(DateTime = temp$DateTime[1],
Sensor = sensor,
BPMfft = round(BPMfft,1),
BPMforecast = round(BPMforecast,1),
BPMpeaks = BPMprac,
BPMagreeQuality.fft.forecast = BPMagreeQuality.fft.forecast,
BPMagreeQuality.prac.forecast = BPMagreeQuality.prac.forecast,
BPMagreeQuality.prac.fft = BPMagreeQuality.prac.fft,
BPMforecastflag = BPMforecastflag,
WeakSignalFlag = WeakSignalFlag,
FilteredAmplitude = round(amp,1),
finalBPM = NA,
finalfilter = 1/highband,
QA = FALSE)
# If there is reasonable agreement between the 3 beats per minute estimates,
# record the mean of the 3 values as the finalBPM
if (resultsList$BPMagreeQuality.fft.forecast <= BPMqualityThreshold &
resultsList$BPMagreeQuality.prac.forecast <= BPMqualityThreshold &
resultsList$BPMagreeQuality.prac.fft <= BPMqualityThreshold &
resultsList$WeakSignalFlag == 'OK') {
resultsList$finalBPM = round(mean(resultsList$BPMfft,
resultsList$BPMforecast,
resultsList$BPMpeaks), digits = 1)
}
} else if (length( which( is.na(temp[,sensor]) ) ) > 0) {
# Handle the case where there are NAs in the data chunk that prevent
# the filtering and fft routines
resultsList = list(DateTime = temp$DateTime[1],
Sensor = sensor,
BPMfft = NA,
BPMforecast = NA,
BPMpeaks = NA,
BPMagreeQuality.fft.forecast = NA,
BPMagreeQuality.prac.forecast = NA,
BPMagreeQuality.prac.fft = NA,
BPMforecastflag = 'FAIL',
WeakSignalFlag = 'FAIL',
FilteredAmplitude = NA,
finalBPM = NA,
finalfilter = NA,
QA = FALSE
)
}
return(resultsList)
}
# Go through the data files for a particular sensor and try to automatically
# estimate the heart rate
# Step through 1 minute at a time
#mytime = as.POSIXct('2020-12-22 12:00',tz='etc/GMT+8')
# TODO wrap the code below in a control structure that will let you specify
# an oyster code and then process that oyster's raw IR data
options(digits.secs = 3) # used to preserve milliseconds values in time stamps
oy = 'W.E.3.1010'
Heart = read.csv(paste0(comboheartpath,oy,'_comboheart.csv'))
Heart$DateTime = as.POSIXct(Heart$DateTime, tz = 'UTC')
# Figure out where the start of each 30-second sampling bout should be.
# The sampling bouts were typically separated by 5 minutes, so we'll just
# look for any time gap that's bigger than 60 seconds.
steps = diff(Heart$DateTime)
bigsteps = which(steps > 60)
bigsteps = bigsteps+1
bigsteps = c(1,bigsteps) # A set of row indices in Heart for each new sample period
pb = txtProgressBar(min = 0, max = length(bigsteps), style = 3)
mylowband = 1/100  # filtering
myhighband = 1/15  # filtering - changing this has the largest effect, start around 1/15
myThreshold = 4 # Minimum agreement between BPM estimates
for (i in 1:length(bigsteps)){
setTxtProgressBar(pb,i)
#	t1 = which.min(abs(Heart$DateTime - bigsteps[i]))
# Test that we've hit the chosen minute (not just the closest time)
#	if (difftime(bigsteps[i],Heart$DateTime[t1], units = 'secs') == 0){
res1 = getBPM(Heart, t1 = bigsteps[i], sensor = 'IR', chunklength = 240,
lowband = mylowband, highband = myhighband, amplitudeThreshold = 20,
BPMqualityThreshold = myThreshold,
maxBPM = 80, Fs = 0.125, plot = FALSE)
if (i == 1) {
SensorResult = as.data.frame(res1)
SensorResult[2:length(bigsteps),] = NA
} else {
SensorResult[i,] = as.data.frame(res1)
}
#	} else {
#		SensorResult$DateTime[i] = timesteps[i]
#
#	}
}
close(pb)
# Add a column with the oyster code
SensorResult$OysterCode = oy
# Save an output file for faster loading in next chunks
write.csv(SensorResult,
file = paste0(heartoutputpath,oy,'_bpm.csv'),
row.names=FALSE)
####################################################################################
# Creating basic interactive graphing routines that allow a user to press a
# particular key to create some response
# 2 functions to allow user interaction with a graph
readkeygraph <- function(prompt)
{
getGraphicsEvent(prompt = prompt,
onMouseDown = NULL, onMouseMove = NULL,
onMouseUp = NULL, onKeybd = onKeybd,
consolePrompt = "Enter a key:\npress n = next (enters NAs) \nk = keep current values \nr = refilter \nl = less filtering \np = use pracma bpm \nf = use forecast bpm \nb = step back to previous time \nq to quit")
Sys.sleep(0.01)
return(keyPressed)
}
onKeybd <- function(key)
{
keyPressed <<- key
}
# End of function definitions
# Go through the results lists and visually inspect timepoints where the
# heart rate was flagged as questionable. This may be a one-time thing. Run the
# code in this chunk to open the BPM data and extract the data for your
# desired sensor channel ('mysensor'). Then run the code in the next chunk
# to do the manual inspection. You may save your progress at the end of the
# next chunk (manually) so that it will be available here the next time you
# reopen the data file.
mysensor = 'IR'
oy = 'W.E.3.1010'
# Open up the concatenated heart data for this oyster
Heart = read.csv(paste0(comboheartpath,oy,'_comboheart.csv'))
Heart$DateTime = as.POSIXct(Heart$DateTime, tz = 'UTC')
# Open up the output file from the heart rate auto-processing routine
if (length(dir(path = heartoutputpath,
pattern = paste0(oy,'[[:alnum:][:punct:]]*QA.csv'))) == 1){
# If the QA'd version exists already, load that up
Heartbpm = read.csv(paste0(heartoutputpath, oy,'_bpm_QA.csv'))
} else {
# Reopen the original filtered results file, which hasn't had QA started yet
Heartbpm = read.csv(paste0(heartoutputpath,oy,'_bpm.csv'))
}
# Convert DateTime to POSIX
Heartbpm$DateTime = as.POSIXct(Heartbpm$DateTime, tz = 'UTC')
# The heart beat estimates and quality flags are stored in Heartbpm
# Define a BPM quality threshold. The BPM estimates from the various methods should
# be less than this value, meaning they are in close agreement.
BPMqualityThreshold = 4
# Figure out rows where there's disagreement among the 3 methods and also values haven't
# previously been QA'd. If the row already has been QA'd, this will ignore that row.
# This will pull out any row where the disagreement
# between 2 of the methods is greater than the BPMqualityThreshold
# and the sensor hasn't been QA'd. This will catch rows with
# weak signals though, which may be too many.
checkTheseRows = which( (Heartbpm$BPMagreeQuality.fft.forecast > BPMqualityThreshold |
Heartbpm$BPMagreeQuality.prac.forecast > BPMqualityThreshold |
Heartbpm$BPMagreeQuality.prac.fft > BPMqualityThreshold ) &
Heartbpm$QA == 'FALSE')
# This version requires the WeakSignalFlag field to be OK instead
# of FAIL. Useful in cases where large numbers (thousands) of
# rows would be caught here, but most of them have such a weak signal
# that they're not even worth looking at.
#checkTheseRows = which( (sensor$BPMagreeQuality.fft.forecast > BPMqualityThreshold |
#				sensor$BPMagreeQuality.prac.forecast > BPMqualityThreshold |
#				sensor$BPMagreeQuality.prac.fft > BPMqualityThreshold ) &
#			sensor$QA == 'FALSE' &
#			  sensor$WeakSignalFlag == 'OK')
# Also get the rows with NAs
NArows = which(is.na(Heartbpm$BPMfft) & is.na(Heartbpm$BPMforecast))
# Combine the two sets of bad row indices
badRows = c(checkTheseRows,NArows)
counter = 1 # Start at the first entry in checkTheseRows
if (exists('ManualStart')){
# This won't run automatically, but you can use it to find a starting point in the middle
# of the dataset to start at, if you don't want to start at the first entry
myTime = as.POSIXct('2022-08-22 10:52:30', tz = 'etc/GMT+8')
counter = which.min(abs(myTime - Heartbpm$DateTime[checkTheseRows]))
}
X11(type='Xlib')
X11(type='Xlib')
